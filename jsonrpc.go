package jsonrpc

import (
	"encoding/json"
	"io"
	"sync"
)

// A Connection is a JSON-RPC channel over an existing ReadWriter, such as a socket.
type Connection struct {
	dialect Dialect
	enc     *json.Encoder
	dec     *json.Decoder

	outbox chan map[string]interface{} // outgoing requests and notifications

	lock        sync.Mutex
	nextID      int                   // id to use for the next request
	resultChans map[int]chan Response // request id -> result channel
	stop        chan struct{}         // will be closed on error
	err         error                 // holds any error encountered on read or write
}

// A Dialect is a specific wire encoding of requests and notifications.
type Dialect struct {
	// The RequestMap maps parameters sent a request function (ID, Method,
	// Params) to a map that is JSON marshalled over the wire.
	RequestMap func(int, string, []interface{}) map[string]interface{}
	// The NotificationMap maps parameters sent a request function (Method,
	// Params) to a map that is JSON marshalled over the wire.
	NotificationMap func(string, []interface{}) map[string]interface{}
}

// A Response is a JSON-RPC 2.0 response as received by the server in response
// to a request.
type Response struct {
	ID      int            // Sequence number autogenerated by the request function
	Result  interface{}    // Result of a successfull request; may be nil.
	Error   *ResponseError // Error of an unsuccessfull (but successfully sent) request; may be nil.
	JSONRPC string         // JSON-RPC version string as returned by the server (most likely "2.0" or blank).
}

// A ResponseError is an error object returned by the JSON-RPC server in
// response to unsuccessfull or erroneous requests.
type ResponseError struct {
	Code    int
	Message string
	Data    interface{}
}

// NewConnection creates a new JSON-RPC channel over the specified ReadWriter,
// using a specific Dialect to encode the transmitted data.
func NewConnection(rw io.ReadWriter, dialect Dialect) *Connection {
	enc := json.NewEncoder(rw)
	dec := json.NewDecoder(rw)
	conn := &Connection{
		dialect:     dialect,
		enc:         enc,
		dec:         dec,
		outbox:      make(chan map[string]interface{}),
		stop:        make(chan struct{}),
		resultChans: make(map[int]chan Response),
	}
	go conn.writer()
	go conn.reader()
	return conn
}

/*
A Request function performs a request on the JSON-RPC server when called and
returns a channel where the response may be read.  A nil channel and an error
is returned if the request could not be sent due to communication problems.

The response object that is sent on the channel may contain an error from the
server. The result channel is closed in the case of a read error after sending
the request but before recieving the response.

The meaning of the arguments to the request function is defined by the Dialect,
but in the standard dialect these are simply sent verbatim as the method
arguments.
*/
type Request func(...interface{}) (<-chan Response, error)

// Request returns a new request function for use over the channel.
func (c *Connection) Request(method string) Request {
	return func(params ...interface{}) (<-chan Response, error) {
		res := make(chan Response, 1)

		c.lock.Lock()
		id := c.nextID
		c.resultChans[id] = res
		c.nextID++
		c.lock.Unlock()

		select {
		case <-c.stop:
			// The stop channel has been closed due to an error.
			c.lock.Lock()
			defer c.lock.Unlock()
			return nil, c.err
		case c.outbox <- c.dialect.RequestMap(id, method, params):
			return res, nil
		}
	}
}

// A Notification function performs a notification on the JSON-RPC server when
// called. An error is returned if the request could not be sent due to
// communication problems. The meaning of the arguments to the request function
// is defined by the Dialect, but in the standard dialect these are simply sent
// verbatim as the method arguments.
type Notification func(...interface{}) error

// Notification returns a new notification function for use over the channel.
func (c *Connection) Notification(method string) Notification {
	return func(params ...interface{}) error {
		select {
		case <-c.stop:
			// The stop channel has been closed due to an error.
			c.lock.Lock()
			defer c.lock.Unlock()
			return c.err
		default:
			c.outbox <- c.dialect.NotificationMap(method, params)
			return nil
		}
	}
}

func (c *Connection) writer() {
	for {
		select {
		case <-c.stop:
			// stop channel has been closed due to an error, time to bail
			return
		case wc := <-c.outbox:
			err := c.enc.Encode(wc)
			if err != nil {
				c.lock.Lock()
				defer c.lock.Unlock()
				c.err = err
				close(c.stop)
				return
			}
		}
	}
}

func (c *Connection) reader() {
	defer func() {

		// If we have any outstanding requests pending when the reader exits
		// due to an error, close those channels to signal that there will
		// never be a response and to avoid a deadlock.

		for k, v := range c.resultChans {
			println("warning: shutting down, cancelling lost response for id", k)
			close(v)
		}
	}()

	for {
		var res Response
		err := c.dec.Decode(&res)
		if err != nil {
			c.lock.Lock()
			defer c.lock.Unlock()
			c.err = err
			close(c.stop)
			return
		}

		c.lock.Lock()
		ch, ok := c.resultChans[res.ID]
		delete(c.resultChans, res.ID)
		c.lock.Unlock()

		if !ok {
			println("warning: result for unsent id", res.ID, "(reader out of sync with reality)")
			continue
		}

		ch <- res
	}
}
